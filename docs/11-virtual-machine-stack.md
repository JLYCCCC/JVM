### 虚拟机栈

   **线程私有的**

#### 内存中的栈与堆

- 栈是运行时的单位，而堆是存储的单位

  > 内容

- Java虚拟机栈，以前称Java栈，每个线程创建时都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的Java方法调用

  

- 生命周期和线程的保持一致

  

- 主管Java程序的运行，保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。

  > 特殊说明

- 栈是后进先出的，java的方法也就是栈帧，方法中执行return后，方法(栈帧)就会被弹出，当然如果抛出异常也会被弹出。

  也顺便说一下这个

  ```java
   public int test() {
  
          try {
              //code
              return 1;
  
          } catch (Exception e) {
             //code
              return 2;
              
          } finally {
  
              System.out.println("还是会被执行");
              
          }
  
   }
  ```

  这个即使**try语句中有return它也不会立刻退出方法,，而是执行完finally语句再退出**,一定要记住这个特殊情况啊靓仔。

  > 优点

- 快速有效的存储方式，访问速度仅次于程序计数器



- JVM直接对JAVA栈的操作只有两个

  > 每个方法执行，伴随着进栈（入栈，压栈）
  >
  > 执行结束的出栈

- 栈不存在垃圾回收，但是存在OOM

> Java栈大小是动态或者固定不变的。如果是动态扩展，无法申请到足够内存OOM，如果是固定，线程请求的栈容量超过固定值，则StackOverflowError



顺便列出基础常见的运行时异常



>NullPointerException - 空指针引用异常
>
>ClassCastException - 类型强制转换异常。
>
>IllegalArgumentException - 传递非法参数异常。
>
>ArithmeticException - 算术运算异常
>
>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
>
>IndexOutOfBoundsException - 下标越界异常
>
>NegativeArraySizeException - 创建一个大小为负数的数组错误异常
>
>NumberFormatException - 数字格式异常
>
>SecurityException - 安全异常
>
>UnsupportedOperationException - 不支持的操作异常

#### jvm调参

>-Xss 设置线程栈的最大空间

#### 静态语言和动态语言

>区别在于对类型的检查是编译器还是运行期，满足编译期就是静态类型语言，反之就是动态类型语言。

> Java是静态类型语言，动态调用指令增加了动态语言的特性

#### 栈的内部结构

- 局部变量表

> - 定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及return address类型
>
>   
>
> - 局部变量表建立在线程的栈上，是线程私有的, 所以不会存在线程安全问题
>
>   
>
> - 局部变量表容量大小是在编译期确定下来的
>
>   
>
> - 局部变量表存放编译期可知的各种基本数据类型（8种），引用类型（reference）,return address 类型
>
>   

> - 最基本的存储单元是slot,32位占用一个slot，64位类型（long和double）占用两个slot

- 动态链接

> 方法的调用
>
> - 静态链接  -> 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接
>
> 
>
> - 动态链接 - >如果被调用的方法无法再编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接
>
> 
>
> - 方法的绑定 - >绑定是一个字段、方法、或者类在符号引用被替换为直接引用的过程。仅仅发生一次。
>
> 
>
> - 早期绑定 ->被调用的目标方法如果再编译期可知，且运行期保持不变
>
> 
>
> - 晚期绑定 ->被调用的方法在编译期无法被确定，只能够在程序运行期根据实际的类型绑定相关的方法。

**Java中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++中则使用关键字virtual来显式定义
如果在java程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字final来标记这个方法**

